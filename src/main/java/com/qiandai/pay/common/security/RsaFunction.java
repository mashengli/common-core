package com.qiandai.pay.common.security;import java.io.FileInputStream;import java.io.IOException;import java.security.Key;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.security.SecureRandom;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import javax.crypto.Cipher;import org.apache.commons.io.IOUtils;/** * User: wandongdong * <p/> * Date: 2013-5-23 * <p/> * Time: 12:22:20 * <p/> * To change this template use File | Settings | File Templates. */public final class RsaFunction {    /**     * 字节数组转化为十六进制字符串     *     * @param b     * @return     */    public static String BytesToHexStr(byte[] b) {        StringBuilder buff = new StringBuilder();        for (byte aB : b) {            if (Integer.toHexString(0xFF & aB).length() == 1) { //如果一个byte小于等于15，                //Integer.toHexString转换成后前面不会添0，所以这里要判断                buff.append("0").append(Integer.toHexString(0xFF & aB));            } else {                buff.append(Integer.toHexString(0xFF & aB));            }        }        return buff.toString().toUpperCase();    }    /**     * 十六进制字符串转换为字节数组     *     * @param hexStr     * @return     */    public static byte[] HexStrToBytes(String hexStr) {        byte[] bytes = new byte[hexStr.length() / 2];        for (int i = 0; i < bytes.length; i++) {            bytes[i] = (byte) Integer.parseInt(hexStr.substring(2 * i, 2 * i + 2), 16);        }        return bytes;    }    /**     * RSA算法加密     *     * @param decodeStr     * @param publicKey     * @return     */    public static String GetEncodeRSAStr(String decodeStr, PublicKey publicKey) {        String encodeStr = null;        try {            Cipher cipher = Cipher.getInstance("RSA/ECB/NOPADDING");            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            byte[] b = cipher.doFinal(decodeStr.getBytes("UTF-8"));            encodeStr = BytesToHexStr(b);        } catch (Exception ignored) {        }        return encodeStr;    }    /**     * RSA算法解密     *     * @param encodeStr     * @param privateKey     * @return     */    public static String GetDecodeRSAStr(String encodeStr, PrivateKey privateKey) {        String decodeStr = null;        try {            Cipher cipher = Cipher.getInstance("RSA/ECB/NOPADDING");            cipher.init(Cipher.DECRYPT_MODE, privateKey);            byte[] b = cipher.doFinal(HexStrToBytes(encodeStr));            decodeStr = new String(b, "UTF-8").trim();        } catch (Exception ignored) {        }        return decodeStr;    }    /**     * 生成RSA密钥对文件     *     * @throws Exception     */    public static void MakeKeyPair() throws Exception {        KeyPairGenerator keygen = KeyPairGenerator.getInstance("RSA");        SecureRandom random = new SecureRandom();        random.setSeed("ADFSIUHFDU".getBytes());  //ADFSIUHFDU        // 初始加密，长度为512，必须是大于512才可以的        keygen.initialize(1024, random);        // 取得密钥对        KeyPair kp = keygen.generateKeyPair();        // 取得公钥        RSAPublicKey publicKey = (RSAPublicKey) kp.getPublic();        // 取得私钥        RSAPrivateKey privateKey = (RSAPrivateKey) kp.getPrivate();    }    /**     * 把字节数组转化为Key     *     * @param hexKey     * @param type     * @return     * @throws Exception     */    public static Key LoadKey(byte[] hexKey, String type) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            if (type.equals("PrivateKey")) {                PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(hexKey);                return keyFactory.generatePrivate(priPKCS8);            } else {                X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(hexKey);                return keyFactory.generatePublic(bobPubKeySpec);            }        } catch (Exception e) {            return null;        }    }    /**     * 从文件中读取密钥     *     * @param filename     * @param type     * @return     * @throws Exception     */    public static Key LoadKey(String filename, String type) throws Exception {        byte[] key = null;        FileInputStream fileIn = null;        try {            fileIn = new FileInputStream(filename);            key = new byte[fileIn.available()];            fileIn.read(key);        } catch (IOException ignored) {        } finally {            IOUtils.closeQuietly(fileIn);        }        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        if (("PrivateKey").equals(type)) {            PKCS8EncodedKeySpec priPKCS8 = new PKCS8EncodedKeySpec(key);            return keyFactory.generatePrivate(priPKCS8);        } else {            X509EncodedKeySpec bobPubKeySpec = new X509EncodedKeySpec(key);            return keyFactory.generatePublic(bobPubKeySpec);        }    }    /**     * 二进制字符串按位取反     *     * @param hexStr     * @return     */    public static String HexStrNegated(String hexStr) {        byte[] b = HexStrToBytes(hexStr);        for (int i = 0; i < b.length; i++) {            b[i] = (byte) ~b[i];        }        return BytesToHexStr(b);    }    public static void main(String[] args) {        //明文        String mingstr = "123456789";        //公钥        String pubkey = "30819F300D06092A864886F70D010101050003818D003081890281810087B5813D1B95DAF5DDDB34C4F19A4EA0FF3AD4103C2B3001E936550C9422FF8B5308D394F8C4A1A6DAFA73A1F5C0652F57023A981556665BA51A6076CB32D7BFF98BB1C73501D2AFE6DF3E7F2AEBC6CDEF11ED0DE37A76094D323696784CD558962E4B7DAA5C9A9C0CD8574445585A88DD593777F6C5879B38FCA09886AEAB070203010001";        //私钥        String prikey = "30820277020100300D06092A864886F70D0101010500048202613082025D0201000281810087B5813D1B95DAF5DDDB34C4F19A4EA0FF3AD4103C2B3001E936550C9422FF8B5308D394F8C4A1A6DAFA73A1F5C0652F57023A981556665BA51A6076CB32D7BFF98BB1C73501D2AFE6DF3E7F2AEBC6CDEF11ED0DE37A76094D323696784CD558962E4B7DAA5C9A9C0CD8574445585A88DD593777F6C5879B38FCA09886AEAB0702030100010281802FB2F930FC5028BD0074BAD07A470D5A033BAF2BE1AA205E9B94F041D293969466E41452293A1BC364F660CC4D6F89612148F4455E429709A1376B2E75EF71EB4EF299A8C89EC2A6A0A3DCE9E571E4C4276117B043CEC655A809BB9CFF4FCB909C3D3FF93C7BF3CE725732BDD905BA8AC56CE49A72AC784E096437FDADCC63A9024100E77ADC71EF030C99FFE3A99F3BA6BFDD2027619F5B4B36DCBFB0F3C36021F6EA9900669576912CC87875CD600233662943F92C7B0487C5555D9C5E5466D9811D0241009615954AEF4AE5FCF8AE5EA7901883DE0380AD2DF7CEEF768ADDDFB799B2A7BF21887D3EED5AE3E73A09323497EC4AA4646696A5DE64B64698039CBE10736773024100E3377C6FF1D722658002AF1B786843E90088E7908F029385B83C2FEAD5D0411922BA7BF7B67CE66299ABB8BEC72A40DBBCB737EC41142CA590CFCEE0365CC619024047EA41A62D715B30D34C6248B2503CE7A610036B926192F6DF659F6C4F767ED0A3D5CE05D820043268E9BD27DC603A07F99FFAB1B215DA0D8B8BB7908F3B6D27024100D58DF79A3C8EEDEC80B4BEB2AB0C859C4C1F1ABC7A4A5CD745B822A38A5F9CA0052C30ABEE0A520997E4E55CEAC9D907D1B412878C6B38F3DA9BF94BBA89ADCC";        //密文，此处可更改为PHP使用公钥加密后得出的密文        String mistr = "3dcecaa8edabc504e0f2020966b8ac4b16e8aad2f63cb9a0ba7569760cd2ae14fe5bdb2dcebbd6674537adba8c661881aea853a95f948f31613cbf678257f0c72f63125716a4651e8dfbc67ba64721f528cf09b1918ddd03cbfca0b2e5bbbe6a4b60374882664ec974d095d13562f7e4b3af9b87117077faf0f0b031c3348d48";        PublicKey publicKey = (PublicKey) LoadKey(HexStrToBytes(pubkey), "PublicKey");        System.out.println("after encode by public key--> " + GetEncodeRSAStr(mingstr, publicKey));        byte[] key = HexStrToBytes(prikey);        RSAPrivateKey key1 = (RSAPrivateKey) LoadKey(key, "PrivateKey");        System.out.println("after decode by private key --> " + GetDecodeRSAStr(mistr, key1));    }}